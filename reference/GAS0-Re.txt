// ==============================
// è¨­å®šç®¡ç†
// ==============================
class SystemConfig {
  constructor() {
    this.properties = PropertiesService.getScriptProperties();
    this.initializeConfig();
  }
  initializeConfig() {
    const defaultConfig = {
      SPREADSHEET_ID: '1-q239hLHhHydeFfd4mE-c9xhOfznlvAaYtp_X5Yx3fg',
      MODEL: 'gpt-4',
      MAX_TOKENS: '1000',
      ENVIRONMENT: 'development',
      LOG_LEVEL: 'INFO',
      GIGAFILE_ENABLED: 'true',
      GIGAFILE_MAX_RETRY: '3',
      GIGAFILE_RETRY_DELAY: '2000'
    };
    Object.entries(defaultConfig).forEach(([key, value]) => {
      if (!this.properties.getProperty(key)) {
        this.properties.setProperty(key, value);
      }
    });
  }
  get(key) {
    const value = this.properties.getProperty(key);
    if (value == null) throw new SystemError(`Configuration key '${key}' not found`);
    return value;
  }
  getNumber(key) { return parseInt(this.get(key), 10); }
  getBoolean(key) { return this.get(key).toLowerCase() === 'true'; }
  set(key, value) { this.properties.setProperty(key, String(value)); }
  getOpenAIKey() {
    const key = this.properties.getProperty('OPENAI_API_KEY');
    if (!key) throw new SystemError('OpenAI API key not configured. Set OPENAI_API_KEY.');
    return key;
  }
  getSpreadsheetId() { return this.get('SPREADSHEET_ID'); }
  getModel() { return this.get('MODEL'); }
  getMaxTokens() { return this.getNumber('MAX_TOKENS'); }
  isProduction() { return this.get('ENVIRONMENT') === 'production'; }
  isDevelopment() { return this.get('ENVIRONMENT') === 'development'; }
  isGigaFileEnabled() { return this.getBoolean('GIGAFILE_ENABLED'); }
  getGigaFileMaxRetry() { return this.getNumber('GIGAFILE_MAX_RETRY'); }
  getGigaFileRetryDelay() { return this.getNumber('GIGAFILE_RETRY_DELAY'); }
}
const config = new SystemConfig();

// ==============================
// ã‚¨ãƒ©ãƒ¼ãƒ»ãƒ­ã‚¬ãƒ¼
// ==============================
class SystemError extends Error {
  constructor(message, code = 'GENERAL_ERROR', statusCode = 500, details = {}) {
    super(message);
    this.name = 'SystemError';
    this.code = code;
    this.statusCode = statusCode;
    this.details = details;
    this.timestamp = new Date().toISOString();
  }
}
class ErrorHandling {
  static handle(error, context = {}) {
    let systemError;
    if (error instanceof SystemError) {
      systemError = error;
    } else {
      systemError = new SystemError(
        error.message || 'Unknown error',
        'UNEXPECTED_ERROR',
        500,
        { originalError: error.toString() }
      );
    }
    SystemLogger.error(systemError.message, systemError, {
      context,
      code: systemError.code,
      statusCode: systemError.statusCode,
      details: systemError.details
    });
    return {
      success: false,
      error: {
        message: systemError.message,
        code: systemError.code,
        timestamp: systemError.timestamp,
        ...(config.isProduction() ? {} : { details: systemError.details })
      }
    };
  }
  static createApiError(message, code = 'API_ERROR') {
    return new SystemError(message, code, 400);
  }
  static createValidationError(message, field = null) {
    return new SystemError(message, 'VALIDATION_ERROR', 400, { field });
  }
  static createNotFoundError(resource) {
    return new SystemError(`${resource} not found`, 'NOT_FOUND', 404);
  }
  static createUnauthorizedError(message = 'Unauthorized') {
    return new SystemError(message, 'UNAUTHORIZED', 401);
  }
}
class SystemLogger {
  static get instance() {
    if (!this._instance) {
      this._instance = new SystemLogger();
    }
    return this._instance;
  }
  constructor() {
    this.logLevel = config.get('LOG_LEVEL');
    this.levels = { DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3 };
  }
  shouldLog(level) { 
    return this.levels[level] >= this.levels[this.logLevel]; 
  }
  formatMessage(level, message, context = {}) {
    return JSON.stringify({ 
      timestamp: new Date().toISOString(), 
      level, 
      message, 
      ...context 
    });
  }
  static debug(msg, ctx) { 
    const instance = SystemLogger.instance;
    if (instance.shouldLog('DEBUG')) {
      console.log(instance.formatMessage('DEBUG', msg, ctx)); 
    }
  }
  static info(msg, ctx) { 
    const instance = SystemLogger.instance;
    if (instance.shouldLog('INFO')) {
      console.log(instance.formatMessage('INFO', msg, ctx)); 
    }
  }
  static warn(msg, ctx) { 
    const instance = SystemLogger.instance;
    if (instance.shouldLog('WARN')) {
      console.warn(instance.formatMessage('WARN', msg, ctx)); 
    }
  }
  static error(msg, err = null, ctx = {}) {
    const instance = SystemLogger.instance;
    if (!instance.shouldLog('ERROR')) return;
    const errorCtx = err ? { 
      error: { 
        message: err.message, 
        stack: err.stack 
      } 
    } : {};
    console.error(instance.formatMessage('ERROR', msg, { ...ctx, ...errorCtx }));
  }
  static logApiCall(method, url, duration, status) {
    SystemLogger.info('API å‘¼ã³å‡ºã—', {
      method,
      url: url.replace(/sk-[^&]+/, 'sk-***'),
      duration,
      status
    });
  }
  static logSession(action, sessionId, ctx = {}) {
    SystemLogger.info(`ã‚»ãƒƒã‚·ãƒ§ãƒ³${action}`, { sessionId, action, ...ctx });
  }
}
class SystemUtils {
  static generateUUID() {
    return Utilities.getUuid();
  }
  static generateFileName(sessionId, extension = 'webm') {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    return `interview_${sessionId}_${timestamp}.${extension}`;
  }
  static sanitizeFileName(fileName) {
    return fileName.replace(/[^a-zA-Z0-9._-]/g, '_');
  }
  static formatResponse(success, data = null, message = null) {
    const response = {
      success,
      timestamp: new Date().toISOString()
    };
    if (success) {
      response.data = data;
      if (message) response.message = message;
    } else {
      response.error = data;
    }
    return response;
  }
  static createBoundary() {
    return '----WebKitFormBoundary' + Utilities.getUuid().replace(/-/g, '');
  }
  static base64ToBlob(base64Data, contentType = 'application/octet-stream') {
    const binaryData = Utilities.base64Decode(base64Data);
    return Utilities.newBlob(binaryData, contentType);
  }
}
// ==============================
// ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
// ==============================
class DataValidator {
  static validateRequired(v, field) {
    if (v === null || v === undefined || v === '') {
      throw ErrorHandling.createValidationError(`${field} is required`, field);
    }
  }
  static validateString(v, field, min = 0, max = Infinity) {
    this.validateRequired(v, field);
    if (typeof v !== 'string') {
      throw ErrorHandling.createValidationError(`${field} must be a string`, field);
    }
    if (v.length < min) {
      throw ErrorHandling.createValidationError(`${field} must be at least ${min} characters`, field);
    }
    if (v.length > max) {
      throw ErrorHandling.createValidationError(`${field} must be no more than ${max} characters`, field);
    }
  }
  static validateSessionId(id) {
    this.validateString(id, 'sessionId', 36, 36);
    if (!/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(id)) {
      throw ErrorHandling.createValidationError('Invalid session ID format', 'sessionId');
    }
  }
  static validateResponse(res) {
    this.validateString(res, 'response', 1, 5000);
    return res.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
              .replace(/javascript:/gi, '')
              .replace(/on\w+\s*=/gi, '');
  }
  static validateCandidateName(name) {
    if (name && name.trim()) {
      this.validateString(name.trim(), 'candidateName', 1, 100);
      return name.trim();
    }
    return '';
  }
}

// ==============================
// ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆç®¡ç†
// ==============================
class DataSheetManager {
  constructor() {
    try {
      this.spreadsheet = SpreadsheetApp.openById(config.getSpreadsheetId());
      this.initializeSheets();
      SystemLogger.info('DataSheetManager initialized');
    } catch (e) {
      SystemLogger.error('Spreadsheet init failed', e);
      throw new SystemError('ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ', 'SPREADSHEET_INIT_ERROR');
    }
  }
  initializeSheets() {
    const sheetsConfig = {
      'Questions': {
        headers: ['ID','ã‚«ãƒ†ã‚´ãƒª','è³ªå•å†…å®¹','æœŸå¾…å›ç­”ã‚¿ã‚¤ãƒ—','é‡è¦åº¦','ä½¿ç”¨å¯èƒ½','ä½œæˆæ—¥æ™‚','æ›´æ–°æ—¥æ™‚'],
        sampleData: [
          [1,'è‡ªå·±ç´¹ä»‹','ã¾ãšã€ç°¡å˜ã«è‡ªå·±ç´¹ä»‹ã‚’ãŠé¡˜ã„ã—ã¾ã™ã€‚','ãƒ†ã‚­ã‚¹ãƒˆ',5,true,new Date(),new Date()],
          [2,'ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«','ã‚ãªãŸã®å¾—æ„ãªæŠ€è¡“åˆ†é‡ã«ã¤ã„ã¦æ•™ãˆã¦ãã ã•ã„ã€‚','ã‚¹ã‚­ãƒ«',4,true,new Date(),new Date()],
          [3,'çµŒé¨“','ã“ã‚Œã¾ã§ã§æœ€ã‚‚æŒ‘æˆ¦çš„ã ã£ãŸãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦æ•™ãˆã¦ãã ã•ã„ã€‚','ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰',5,true,new Date(),new Date()],
          [4,'ãƒ¢ãƒãƒ™ãƒ¼ã‚·ãƒ§ãƒ³','å½“ç¤¾ã‚’å¿—æœ›ã™ã‚‹ç†ç”±ã‚’æ•™ãˆã¦ãã ã•ã„ã€‚','ãƒ†ã‚­ã‚¹ãƒˆ',3,true,new Date(),new Date()]
        ]
      },
      'Responses': {
        headers: ['ã‚»ãƒƒã‚·ãƒ§ãƒ³ID','ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—','è³ªå•ID','è³ªå•å†…å®¹','å›ç­”å†…å®¹','å›ç­”æ™‚é–“(ç§’)','AIè©•ä¾¡æ¦‚è¦','ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰','ã‚¹ã‚³ã‚¢','è©³ç´°åˆ†æ']
      },
      'Sessions': {
        headers: ['ã‚»ãƒƒã‚·ãƒ§ãƒ³ID','é–‹å§‹æ™‚åˆ»','çµ‚äº†æ™‚åˆ»','å€™è£œè€…å','ç·è³ªå•æ•°','å¹³å‡ã‚¹ã‚³ã‚¢','ç·ã‚¹ã‚³ã‚¢','ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹','å‚™è€ƒ','IP ã‚¢ãƒ‰ãƒ¬ã‚¹']
      },
      'Logs': {
        headers: ['ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—','ãƒ¬ãƒ™ãƒ«','ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸','ã‚»ãƒƒã‚·ãƒ§ãƒ³ID','è©³ç´°']
      },
      'Recordings': {
        headers: ['ã‚»ãƒƒã‚·ãƒ§ãƒ³ID','ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ™‚åˆ»','ãƒ•ã‚¡ã‚¤ãƒ«å','ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º(bytes)','éŒ²ç”»æ™‚é–“(ç§’)','ã‚®ã‚¬ãƒ•ã‚¡ã‚¤ãƒ«ä¾¿URL','ã‚®ã‚¬ãƒ•ã‚¡ã‚¤ãƒ«ä¾¿ID','æœ‰åŠ¹æœŸé™','ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰çŠ¶æ³','ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸']
      }
    };
    Object.entries(sheetsConfig).forEach(([name, config]) => {
      this[`${name.toLowerCase()}Sheet`] = this.getOrCreateSheet(name, () => 
        this.createSheetWithHeaders(name, config.headers, config.sampleData)
      );
    });
  }
  getOrCreateSheet(name, createFn) { 
    return this.spreadsheet.getSheetByName(name) || createFn(); 
  }
  createSheetWithHeaders(name, headers, sampleData = null) {
    const sheet = this.spreadsheet.insertSheet(name);
    sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
    if (sampleData) {
      sheet.getRange(2, 1, sampleData.length, sampleData[0].length).setValues(sampleData);
    }
    this.formatHeaders(sheet, headers.length);
    return sheet;
  }
  formatHeaders(sheet, cols) {
    const range = sheet.getRange(1, 1, 1, cols);
    range.setBackground('#4285f4').setFontColor('white').setFontWeight('bold');
    sheet.setFrozenRows(1);
  }
  getAvailableQuestions() {
    const data = this.questionsSheet.getDataRange().getValues();
    if (data.length <= 1) return [];
    return data.slice(1)
      .filter(r => r[5] === true)
      .map(r => ({
        id: r[0], 
        category: r[1], 
        content: r[2], 
        expectedType: r[3],
        importance: r[4], 
        available: r[5], 
        createdAt: r[6], 
        updatedAt: r[7]
      }));
  }
  async saveResponse(sessionId, qId, qContent, resp, respTime, evalObj) {
    const row = [
      sessionId, new Date(), qId, qContent, resp, respTime,
      evalObj.summary,
      Array.isArray(evalObj.keywords) ? evalObj.keywords.join(', ') : '',
      evalObj.score,
      JSON.stringify({
        strengths: evalObj.strengths,
        concerns: evalObj.concerns,
        followUpSuggestions: evalObj.followUpSuggestions
      })
    ];
    this.responsesSheet.appendRow(row);
    SystemLogger.logSession('å›ç­”ä¿å­˜', sessionId, { questionId: qId, score: evalObj.score });
  }
  async saveSession(data) {
    this.sessionsSheet.appendRow([
      data.sessionId, data.startTime, data.endTime || '', data.candidateName || '',
      data.totalQuestions || 0, data.averageScore || 0, data.totalScore || 0,
      data.status || 'active', data.notes || '', data.ipAddress || ''
    ]);
    SystemLogger.logSession('ã‚»ãƒƒã‚·ãƒ§ãƒ³ä¿å­˜', data.sessionId, { candidateName: data.candidateName });
  }
  updateSessionStatus(sessionId, status, endTime = null, more = {}) {
    const data = this.sessionsSheet.getDataRange().getValues();
    const headers = data[0];
    const sidIdx = headers.indexOf('ã‚»ãƒƒã‚·ãƒ§ãƒ³ID');
    const stIdx = headers.indexOf('ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹');
    const etIdx = headers.indexOf('çµ‚äº†æ™‚åˆ»');
    for (let i = 1; i < data.length; i++) {
      if (data[i][sidIdx] === sessionId) {
        this.sessionsSheet.getRange(i+1, stIdx+1).setValue(status);
        if (endTime) this.sessionsSheet.getRange(i+1, etIdx+1).setValue(endTime);
        Object.entries(more).forEach(([k,v]) => {
          const col = headers.indexOf(k);
          if (col !== -1) this.sessionsSheet.getRange(i+1, col+1).setValue(v);
        });
        break;
      }
    }
    SystemLogger.logSession('ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°', sessionId, { status });
  }
  saveLog(level, msg, sessionId = '', details = {}) {
    this.logsSheet.appendRow([new Date(), level, msg, sessionId, JSON.stringify(details)]);
  }
  saveRecordingMetadata(data) {
    this.recordingsSheet.appendRow([
      data.sessionId, data.uploadTime, data.fileName, data.fileSize,
      data.duration, data.gigaFileUrl, data.gigaFileId, data.expiryDate,
      data.uploadStatus, data.errorMessage
    ]);
  }
}

// ==============================
// ã‚®ã‚¬ãƒ•ã‚¡ã‚¤ãƒ«ä¾¿ç®¡ç†
// ==============================
class GigaFileService {
  constructor() {
    this.apiBaseUrl = 'https://gigafile.nu/api';
    this.maxRetries = config.getGigaFileMaxRetry();
    this.retryDelay = config.getGigaFileRetryDelay();
  }
  async uploadFile(binaryData, fileName, sessionId) {
    if (!config.isGigaFileEnabled()) {
      throw new SystemError('ã‚®ã‚¬ãƒ•ã‚¡ã‚¤ãƒ«ä¾¿ãŒç„¡åŠ¹ã«ãªã£ã¦ã„ã¾ã™', 'GIGAFILE_DISABLED');
    }
    const boundary = SystemUtils.createBoundary();
    const payload = this.createMultipartPayload(binaryData, fileName, boundary);
    const options = {
      method: 'POST',
      headers: {
        'Content-Type': `multipart/form-data; boundary=${boundary}`
      },
      payload: payload
    };
    const startTime = Date.now();
    let lastError;
    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
      try {
        SystemLogger.info(`ã‚®ã‚¬ãƒ•ã‚¡ã‚¤ãƒ«ä¾¿ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰è©¦è¡Œ ${attempt}/${this.maxRetries}`, {
          sessionId,
          fileName,
          attempt,
          fileSize: binaryData.length
        });
        const response = await this.executeUpload(options);
        const duration = Date.now() - startTime;
        SystemLogger.logApiCall('POST', 'gigafile.nu/api/upload', duration, 200);
        SystemLogger.info('ã‚®ã‚¬ãƒ•ã‚¡ã‚¤ãƒ«ä¾¿ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æˆåŠŸ', {
          sessionId,
          fileName,
          duration,
          attempts: attempt
        });
        return {
          success: true,
          downloadUrl: response.download_url,
          gigaFileId: response.file_id,
          expiryDate: response.expiry_date,
          uploadTime: new Date().toISOString(),
          fileName: fileName,
          fileSize: binaryData.length
        };
      } catch (error) {
        lastError = error;
        SystemLogger.warn(`ã‚®ã‚¬ãƒ•ã‚¡ã‚¤ãƒ«ä¾¿ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å¤±æ•— (è©¦è¡Œ ${attempt}/${this.maxRetries})`, {
          sessionId,
          fileName,
          error: error.message,
          attempt
        });
        if (attempt < this.maxRetries) {
          await this.delay(this.retryDelay * attempt);
        }
      }
    }
    throw new SystemError(
      `ã‚®ã‚¬ãƒ•ã‚¡ã‚¤ãƒ«ä¾¿ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ: ${lastError.message}`,
      'GIGAFILE_UPLOAD_FAILED',
      500,
      { sessionId, fileName, attempts: this.maxRetries }
    );
  }
  createMultipartPayload(binary, fileName, boundary) {
    const CRLF = '\r\n';
    const header = [
      `--${boundary}`,
      `Content-Disposition: form-data; name="file"; filename="${fileName}"`,
      'Content-Type: video/webm',
      '', ''
    ].join(CRLF);
    const footer = `${CRLF}--${boundary}--${CRLF}`;
    const headerBytes = Utilities.newBlob(header).getBytes();
    const footerBytes = Utilities.newBlob(footer).getBytes();
    const total = headerBytes.length + binary.length + footerBytes.length;
    const buf = new Uint8Array(total);
    buf.set(headerBytes, 0);
    buf.set(binary, headerBytes.length);
    buf.set(footerBytes, headerBytes.length + binary.length);
    return buf;
  }
  async executeUpload(options) {
    const response = UrlFetchApp.fetch(`${this.apiBaseUrl}/upload`, options);
    if (response.getResponseCode() !== 200) {
      throw new Error(`HTTP ${response.getResponseCode()}: ${response.getContentText()}`);
    }
    const data = JSON.parse(response.getContentText());
    if (!data.success) {
      throw new Error(data.message || 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
    return data;
  }
  async delay(ms) {
    return new Promise(resolve => {
      Utilities.sleep(ms);
      resolve();
    });
  }
}

// ==============================
// éŒ²ç”»ç®¡ç†
// ==============================
class RecordingService {
  constructor() {
    this.sheetManager = new DataSheetManager();
    this.gigaFileService = new GigaFileService();
    this.activeSessions = new Map();
  }
  async saveRecording(sessionId, binaryData, fileName, metadata = {}) {
    DataValidator.validateSessionId(sessionId);
    const safeName = SystemUtils.sanitizeFileName(fileName) || 
                    SystemUtils.generateFileName(sessionId);
    try {
      const uploadResult = await this.gigaFileService.uploadFile(binaryData, safeName, sessionId);
      await this.sheetManager.saveRecordingMetadata({
        sessionId,
        fileName: safeName,
        uploadTime: new Date(),
        fileSize: binaryData.length,
        duration: metadata.duration || 0,
        gigaFileUrl: uploadResult.downloadUrl,
        gigaFileId: uploadResult.gigaFileId,
        expiryDate: uploadResult.expiryDate,
        uploadStatus: 'completed',
        errorMessage: ''
      });
      SystemLogger.logSession('éŒ²ç”»ä¿å­˜å®Œäº†', sessionId, { 
        fileName: safeName, 
        url: uploadResult.downloadUrl 
      });
      return uploadResult;
    } catch (error) {
      await this.sheetManager.saveRecordingMetadata({
        sessionId,
        fileName: safeName,
        uploadTime: new Date(),
        fileSize: binaryData.length,
        duration: metadata.duration || 0,
        gigaFileUrl: '',
        gigaFileId: '',
        expiryDate: '',
        uploadStatus: 'failed',
        errorMessage: error.message
      });
      throw error;
    }
  }
  startRecordingSession(sessionId, metadata = {}) {
    DataValidator.validateSessionId(sessionId);
    if (this.activeSessions.has(sessionId)) {
      throw ErrorHandling.createValidationError('Recording session already active', 'sessionId');
    }
    const sessionData = {
      sessionId,
      startTime: new Date(),
      status: 'recording',
      metadata,
      chunks: [],
      totalSize: 0
    };
    this.activeSessions.set(sessionId, sessionData);
    SystemLogger.logSession('éŒ²ç”»é–‹å§‹', sessionId);
    return SystemUtils.formatResponse(true, {
      sessionId,
      status: 'recording',
      message: 'éŒ²ç”»ã‚’é–‹å§‹ã—ã¾ã—ãŸ'
    });
  }
  stopRecordingSession(sessionId) {
    const session = this.getActiveSession(sessionId);
    session.status = 'stopped';
    session.endTime = new Date();
    const duration = Math.floor((session.endTime - session.startTime) / 1000);
    this.activeSessions.delete(sessionId);
    SystemLogger.logSession('éŒ²ç”»åœæ­¢', sessionId, { duration });
    return SystemUtils.formatResponse(true, {
      sessionId,
      status: 'stopped',
      duration,
      message: 'éŒ²ç”»ã‚’åœæ­¢ã—ã¾ã—ãŸ'
    });
  }
  getRecordingStatus(sessionId) {
    const session = this.activeSessions.get(sessionId);
    if (!session) {
      return SystemUtils.formatResponse(true, {
        sessionId,
        status: 'inactive',
        message: 'éŒ²ç”»ã‚»ãƒƒã‚·ãƒ§ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'
      });
    }
    const duration = Math.floor((Date.now() - session.startTime) / 1000);
    return SystemUtils.formatResponse(true, {
      sessionId,
      status: session.status,
      startTime: session.startTime.toISOString(),
      duration,
      totalSize: session.totalSize
    });
  }
  getActiveSession(sessionId, expectedStatus = null) {
    const session = this.activeSessions.get(sessionId);
    if (!session) {
      throw ErrorHandling.createNotFoundError('Recording session');
    }
    if (expectedStatus && session.status !== expectedStatus) {
      throw ErrorHandling.createValidationError(
        `Expected session status: ${expectedStatus}, got: ${session.status}`,
        'sessionStatus'
      );
    }
    return session;
  }
}

// ==============================
// AIé¢æ¥ç®¡ç†
// ==============================
class InterviewService {
  constructor() {
    this.apiKey = config.getOpenAIKey();
    this.conversationHistory = new Map();
    this.sheetManager = new DataSheetManager();
  }
  async callOpenAI(messages, functions = null) {
    const startTime = Date.now();
    const payload = {
      model: config.getModel(),
      messages,
      max_tokens: config.getMaxTokens(),
      temperature: 0.7,
      ...(functions ? { functions, function_call: 'auto' } : {})
    };
    const response = UrlFetchApp.fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.apiKey}`,
        'Content-Type': 'application/json'
      },
      payload: JSON.stringify(payload)
    });
    const duration = Date.now() - startTime;
    SystemLogger.logApiCall('POST', 'api.openai.com/v1/chat/completions', duration, response.getResponseCode());
    if (response.getResponseCode() !== 200) {
      throw ErrorHandling.createApiError(`OpenAI API Error: HTTP ${response.getResponseCode()}`);
    }
    const data = JSON.parse(response.getContentText());
    if (data.error) {
      throw ErrorHandling.createApiError(data.error.message);
    }
    return data;
  }
  async startInterview(candidateName = '') {
    const candidate = DataValidator.validateCandidateName(candidateName);
    const sessionId = SystemUtils.generateUUID();
    const startTime = new Date();
    this.conversationHistory.set(sessionId, []);
    await this.sheetManager.saveSession({
      sessionId,
      startTime,
      candidateName: candidate,
      status: 'active'
    });
    const questions = this.sheetManager.getAvailableQuestions();
    if (!questions.length) {
      throw ErrorHandling.createApiError('åˆ©ç”¨å¯èƒ½ãªè³ªå•ãŒã‚ã‚Šã¾ã›ã‚“');
    }
    const firstQuestion = questions.find(q => q.category === 'è‡ªå·±ç´¹ä»‹') || questions[0];
    const welcomeMessage = `ã“ã‚“ã«ã¡ã¯ï¼æœ¬æ—¥ã¯é¢æ¥ã®ãŠæ™‚é–“ã‚’ã„ãŸã ãã€ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚${firstQuestion.content}`;
    this.conversationHistory.set(sessionId, [{
      role: 'assistant',
      content: welcomeMessage
    }]);
    SystemLogger.logSession('é¢æ¥é–‹å§‹', sessionId, { candidateName: candidate });
    return {
      sessionId,
      message: welcomeMessage,
      currentQuestion: firstQuestion,
      timestamp: startTime.toISOString()
    };
  }
  async processResponse(sessionId, response, questionId) {
    DataValidator.validateSessionId(sessionId);
    const cleanResponse = DataValidator.validateResponse(response);
    const history = this.conversationHistory.get(sessionId);
    if (!history) {
      throw ErrorHandling.createNotFoundError('Interview session');
    }
    const questions = this.sheetManager.getAvailableQuestions();
    const currentQuestion = questions.find(q => q.id === questionId);
    if (!currentQuestion) {
      throw ErrorHandling.createNotFoundError('Question');
    }
    history.push({ role: 'user', content: cleanResponse });
    const analysis = await this.analyzeResponse(currentQuestion.content, cleanResponse);
    const responseTime = Math.max(10, Math.floor(cleanResponse.length / 10));
    await this.sheetManager.saveResponse(
      sessionId, 
      questionId, 
      currentQuestion.content, 
      cleanResponse, 
      responseTime, 
      analysis
    );
    const answeredQuestionIds = this.getAnsweredQuestionIds(history).concat(questionId);
    const remainingQuestions = questions.filter(q => !answeredQuestionIds.includes(q.id));
    if (!remainingQuestions.length) {
      await this.sheetManager.updateSessionStatus(sessionId, 'completed', new Date());
      this.conversationHistory.delete(sessionId);
      return {
        sessionId,
        message: 'é¢æ¥ã¯ä»¥ä¸Šã§çµ‚äº†ã§ã™ã€‚ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã—ãŸï¼',
        isComplete: true,
        finalScore: analysis.score,
        previousAnalysis: analysis
      };
    }
    const nextQuestion = await this.selectNextQuestion(sessionId, remainingQuestions);
    const selectedQuestion = remainingQuestions.find(q => q.id === nextQuestion.questionId) || remainingQuestions[0];
    history.push({
      role: 'assistant',
      content: selectedQuestion.content,
      metaQuestionId: selectedQuestion.id
    });
    const progress = {
      answered: answeredQuestionIds.length,
      total: questions.length,
      percentage: Math.round((answeredQuestionIds.length / questions.length) * 100)
    };
    return {
      sessionId,
      message: selectedQuestion.content,
      currentQuestion: selectedQuestion,
      previousAnalysis: analysis,
      isComplete: false,
      progress
    };
  }
  async analyzeResponse(question, response) {
    const systemPrompt = `ã‚ãªãŸã¯çµŒé¨“è±Šå¯Œãªé¢æ¥å®˜ã§ã™ã€‚ä»¥ä¸‹ã®è¦³ç‚¹ã§å›ç­”ã‚’åˆ†æã—ã€JSONã§è¿”ã—ã¦ãã ã•ã„ï¼š
    - score: 1-10ã®æ•°å€¤è©•ä¾¡
    - summary: å›ç­”ã®è¦ç´„
    - keywords: é‡è¦ãªã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®é…åˆ—
    - strengths: è‰¯ã„ç‚¹ã®é…åˆ—
    - concerns: æ‡¸å¿µç‚¹ã®é…åˆ—
    - followUpSuggestions: ãƒ•ã‚©ãƒ­ãƒ¼ã‚¢ãƒƒãƒ—è³ªå•ã®ææ¡ˆé…åˆ—`;
    const messages = [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: `è³ªå•: ${question}\nå›ç­”: ${response}` }
    ];
    try {
      const result = await this.callOpenAI(messages);
      const analysis = JSON.parse(result.choices[0].message.content);
      if (!(analysis.score >= 1 && analysis.score <= 10)) {
        analysis.score = 5;
      }
      if (!Array.isArray(analysis.keywords)) {
        analysis.keywords = [];
      }
      if (!Array.isArray(analysis.strengths)) {
        analysis.strengths = [];
      }
      if (!Array.isArray(analysis.concerns)) {
        analysis.concerns = [];
      }
      if (!Array.isArray(analysis.followUpSuggestions)) {
        analysis.followUpSuggestions = [];
      }
      return analysis;
    } catch (error) {
      SystemLogger.error('AIåˆ†æã«å¤±æ•—ã—ã¾ã—ãŸ', error);
      return {
        score: 5,
        summary: 'åˆ†æã«å¤±æ•—ã—ã¾ã—ãŸ',
        keywords: [],
        strengths: [],
        concerns: ['AIåˆ†æã‚¨ãƒ©ãƒ¼'],
        followUpSuggestions: []
      };
    }
  }
  async selectNextQuestion(sessionId, remainingQuestions) {
    const systemPrompt = `ã‚ãªãŸã¯çµŒé¨“è±Šå¯Œãªé¢æ¥å®˜ã§ã™ã€‚ã“ã‚Œã¾ã§ã®ä¼šè©±ã®æµã‚Œã‚’è€ƒæ…®ã—ã¦ã€æœ€é©ãªæ¬¡ã®è³ªå•ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚
    ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã¯ä»¥ä¸‹ã®JSONå½¢å¼ã§è¿”ã—ã¦ãã ã•ã„ï¼š
    {"questionId": é¸æŠã—ãŸè³ªå•ã®ID}`;
    const history = this.conversationHistory.get(sessionId);
    const messages = [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: `ä¼šè©±å±¥æ­´: ${JSON.stringify(history)}\nåˆ©ç”¨å¯èƒ½ãªè³ªå•: ${JSON.stringify(remainingQuestions)}` }
    ];
    try {
      const result = await this.callOpenAI(messages);
      return JSON.parse(result.choices[0].message.content);
    } catch (error) {
      SystemLogger.error('æ¬¡ã®è³ªå•é¸æŠã«å¤±æ•—ã—ã¾ã—ãŸ', error);
      return { questionId: remainingQuestions[0].id };
    }
  }
  getAnsweredQuestionIds(history) {
    return history
      .filter(msg => msg.role === 'assistant' && msg.metaQuestionId)
      .map(msg => msg.metaQuestionId);
  }
  getSessionStats(sessionId) {
    DataValidator.validateSessionId(sessionId);
    const history = this.conversationHistory.get(sessionId);
    if (!history) {
      throw ErrorHandling.createNotFoundError('Interview session');
    }
    const userMessages = history.filter(msg => msg.role === 'user');
    const assistantMessages = history.filter(msg => msg.role === 'assistant');
    const averageResponseLength = userMessages.length > 0 ? 
      Math.round(userMessages.reduce((sum, msg) => sum + msg.content.length, 0) / userMessages.length) : 0;
    return {
      sessionId,
      totalExchanges: Math.min(userMessages.length, assistantMessages.length),
      averageResponseLength,
      conversationLength: history.length,
      lastActivity: new Date().toISOString()
    };
  }
  async terminateSession(sessionId, reason = 'Manual termination') {
    DataValidator.validateSessionId(sessionId);
    const endTime = new Date();
    await this.sheetManager.updateSessionStatus(sessionId, 'terminated', endTime, {
      'å‚™è€ƒ': reason
    });
    this.conversationHistory.delete(sessionId);
    SystemLogger.logSession('ã‚»ãƒƒã‚·ãƒ§ãƒ³çµ‚äº†', sessionId, { reason });
    return {
      success: true,
      message: 'ã‚»ãƒƒã‚·ãƒ§ãƒ³ãŒçµ‚äº†ã•ã‚Œã¾ã—ãŸ',
      sessionId,
      endTime: endTime.toISOString()
    };
  }
}
// ==============================
// ã‚·ã‚¹ãƒ†ãƒ ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
// ==============================
class SystemHealthCheck {
  static checkConfig() {
    try {
      config.getSpreadsheetId();
      config.getOpenAIKey();
      return { healthy: true, message: 'Configuration OK' };
    } catch (error) {
      return { healthy: false, message: error.message };
    }
  }
  static checkSpreadsheet() {
    try {
      new DataSheetManager();
      return { healthy: true, message: 'Spreadsheet connection OK' };
    } catch (error) {
      return { healthy: false, message: error.message };
    }
  }
  static checkOpenAI() {
    try {
      const apiKey = config.getOpenAIKey();
      return { 
        healthy: true, 
        message: 'API key configured',
        keyLength: apiKey.length 
      };
    } catch (error) {
      return { healthy: false, message: error.message };
    }
  }
  static checkGigaFile() {
    try {
      new GigaFileService();
      return { healthy: true, message: 'GigaFile service OK' };
    } catch (error) {
      return { healthy: false, message: error.message };
    }
  }
  static performHealthCheck() {
    const checks = {
      config: SystemHealthCheck.checkConfig(),
      spreadsheet: SystemHealthCheck.checkSpreadsheet(),
      openai: SystemHealthCheck.checkOpenAI(),
      gigafile: SystemHealthCheck.checkGigaFile()
    };
    const allHealthy = Object.values(checks).every(check => check.healthy);
    return {
      status: allHealthy ? 'healthy' : 'degraded',
      checks,
      version: '2.0.0',
      timestamp: new Date().toISOString()
    };
  }
}

// ==============================
// WebAppã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
// ==============================

// CORSãƒ—ãƒªãƒ•ãƒ©ã‚¤ãƒˆãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å‡¦ç†
function doOptions(e) {
  return ContentService.createTextOutput()
    .addHeader('Access-Control-Allow-Origin', '*') // ã™ã¹ã¦ã®ã‚ªãƒªã‚¸ãƒ³ã‚’è¨±å¯
    .addHeader('Access-Control-Allow-Methods', 'POST, OPTIONS')
    .addHeader('Access-Control-Allow-Headers', 'Content-Type');
}

// JSONãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ç”Ÿæˆï¼ˆCORSãƒ˜ãƒƒãƒ€ãƒ¼ä»˜ãï¼‰
function createJsonResponse(data) {
  const response = ContentService.createTextOutput(JSON.stringify(data))
    .setMimeType(ContentService.MimeType.JSON)
    .addHeader('Access-Control-Allow-Origin', '*'); // ã™ã¹ã¦ã®ã‚ªãƒªã‚¸ãƒ³ã‚’è¨±å¯
  return response;
}

function doGet() {
  try {
    SystemLogger.info('WebApp accessed');
    return HtmlService.createTemplateFromFile('index')
      .evaluate()
      .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL)
      .addMetaTag('viewport', 'width=device-width, initial-scale=1')
      .setTitle('AIé¢æ¥ã‚·ã‚¹ãƒ†ãƒ ');
  } catch (error) {
    SystemLogger.error('doGet error', error);
    return HtmlService.createHtmlOutput('ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ©ãƒ¼ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
  }
}

async function doPost(e) {
  const startTime = Date.now();
  let requestData;
  try {
    requestData = JSON.parse(e.postData.contents);
    const action = requestData.action;
    SystemLogger.info('API request received', {
      action,
      sessionId: requestData.sessionId || 'new',
      timestamp: new Date().toISOString()
    });
    let result;
    switch (action) {
      case 'startInterview':
        result = await handleStartInterview(requestData);
        break;
      case 'submitResponse':
        result = await handleSubmitResponse(requestData);
        break;
      case 'getSessionStats':
        result = await handleGetSessionStats(requestData);
        break;
      case 'terminateSession':
        result = await handleTerminateSession(requestData);
        break;
      case 'healthCheck':
        result = handleHealthCheck();
        break;
      case 'recordingControl':
        result = await handleRecordingControl(requestData);
        break;
      case 'uploadRecording':
        result = await handleRecordingUpload(requestData);
        break;
      default:
        throw ErrorHandling.createValidationError(`Unknown action: ${action}`, 'action');
    }
    const duration = Date.now() - startTime;
    SystemLogger.info('API request completed', {
      action,
      duration,
      success: result.success !== false
    });
    
    // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ä½œæˆ
    return createJsonResponse(SystemUtils.formatResponse(true, result));

  } catch (error) {
    const duration = Date.now() - startTime;
    const errorResponse = ErrorHandling.handle(error, {
      action: requestData?.action || 'unknown',
      duration,
      requestData: config.isProduction() ? 'hidden' : requestData
    });
    
    // ã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹ä½œæˆ
    return createJsonResponse(errorResponse);
  }
}

// ==============================
// APIãƒãƒ³ãƒ‰ãƒ©ãƒ¼é–¢æ•°
// ==============================
async function handleStartInterview(requestData) {
  const interviewService = new InterviewService();
  return await interviewService.startInterview(requestData.candidateName);
}
async function handleSubmitResponse(requestData) {
  DataValidator.validateRequired(requestData.sessionId, 'sessionId');
  DataValidator.validateRequired(requestData.response, 'response');
  DataValidator.validateRequired(requestData.questionId, 'questionId');
  const interviewService = new InterviewService();
  return await interviewService.processResponse(
    requestData.sessionId,
    requestData.response,
    requestData.questionId
  );
}
async function handleGetSessionStats(requestData) {
  DataValidator.validateRequired(requestData.sessionId, 'sessionId');
  const interviewService = new InterviewService();
  return interviewService.getSessionStats(requestData.sessionId);
}
async function handleTerminateSession(requestData) {
  DataValidator.validateRequired(requestData.sessionId, 'sessionId');
  const interviewService = new InterviewService();
  return await interviewService.terminateSession(
    requestData.sessionId,
    requestData.reason || 'User requested termination'
  );
}
function handleHealthCheck() {
  return SystemHealthCheck.performHealthCheck();
}
async function handleRecordingControl(requestData) {
  DataValidator.validateRequired(requestData.command, 'command');
  DataValidator.validateRequired(requestData.sessionId, 'sessionId');
  const recordingService = new RecordingService();
  switch (requestData.command) {
    case 'start':
      return recordingService.startRecordingSession(requestData.sessionId, requestData.metadata || {});
    case 'stop':
      return recordingService.stopRecordingSession(requestData.sessionId);
    case 'status':
      return recordingService.getRecordingStatus(requestData.sessionId);
    default:
      throw ErrorHandling.createValidationError('Invalid recording command', 'command');
  }
}
async function handleRecordingUpload(requestData) {
  DataValidator.validateRequired(requestData.sessionId, 'sessionId');
  DataValidator.validateRequired(requestData.recordingData, 'recordingData');
  DataValidator.validateRequired(requestData.fileName, 'fileName');
  const recordingService = new RecordingService();
  const binaryData = Utilities.base64Decode(requestData.recordingData);
  SystemLogger.info('éŒ²ç”»ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å‡¦ç†é–‹å§‹', {
    sessionId: requestData.sessionId,
    fileName: requestData.fileName,
    dataSize: binaryData.length
  });
  return await recordingService.saveRecording(
    requestData.sessionId,
    binaryData,
    requestData.fileName,
    requestData.metadata || {}
  );
}

// ==============================
// ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
// ==============================
function doOptions(e) {
  const response = ContentService.createTextOutput('');
  response.setMimeType(ContentService.MimeType.JSON);
  return response;
}

function createJsonResponse(data) {
  const response = ContentService.createTextOutput(JSON.stringify(data));
  response.setMimeType(ContentService.MimeType.JSON);
  return response;
}
// ==============================
// åˆæœŸåŒ–ãƒ»ãƒ†ã‚¹ãƒˆé–¢æ•°
// ==============================
function setupConfiguration() {
  try {
    const apiKey = PropertiesService.getScriptProperties().getProperty('OPENAI_API_KEY');
    if (!apiKey) {
      console.log('âš ï¸ OpenAI API keyãŒæœªè¨­å®šã§ã™ã€‚ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã§è¨­å®šã—ã¦ãã ã•ã„:');
      console.log('PropertiesService.getScriptProperties().setProperty("OPENAI_API_KEY", "your-api-key-here");');
    } else {
      console.log('âœ… OpenAI API keyè¨­å®šæ¸ˆã¿');
    }
    SystemLogger.info('è¨­å®šåˆæœŸåŒ–å®Œäº†');
    return SystemUtils.formatResponse(true, null, 'è¨­å®šåˆæœŸåŒ–å®Œäº†');
  } catch (error) {
    SystemLogger.error('è¨­å®šåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼', error);
    return SystemUtils.formatResponse(false, { message: error.message });
  }
}
function initializeSystem() {
  try {
    console.log('ğŸš€ ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–é–‹å§‹');
    const configResult = setupConfiguration();
    if (!configResult.success) {
      throw new Error('è¨­å®šåˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
    new DataSheetManager();
    new InterviewService();
    new RecordingService();
    console.log('âœ… ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†');
    return SystemUtils.formatResponse(true, null, 'ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†');
  } catch (error) {
    console.error('âŒ ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
    SystemLogger.error('ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼', error);
    return SystemUtils.formatResponse(false, { message: error.message });
  }
}
function runSystemTests() {
  if (!config.isDevelopment()) {
    return SystemUtils.formatResponse(false, null, 'ãƒ†ã‚¹ãƒˆã¯é–‹ç™ºç’°å¢ƒã§ã®ã¿å®Ÿè¡Œå¯èƒ½ã§ã™');
  }
  const tests = [
    { name: 'Configuration', fn: () => SystemHealthCheck.checkConfig() },
    { name: 'Spreadsheet', fn: () => SystemHealthCheck.checkSpreadsheet() },
    { name: 'OpenAI', fn: () => SystemHealthCheck.checkOpenAI() },
    { name: 'GigaFile', fn: () => SystemHealthCheck.checkGigaFile() }
  ];
  const results = tests.map(test => {
    try {
      const result = test.fn();
      return { 
        name: test.name, 
        success: result.healthy, 
        message: result.message 
      };
    } catch (error) {
      return { 
        name: test.name, 
        success: false, 
        message: error.message 
      };
    }
  });
  const allPassed = results.every(r => r.success);
  SystemLogger.info('System tests completed', { 
    passed: allPassed, 
    results 
  });
  return SystemUtils.formatResponse(allPassed, results, 
    allPassed ? 'å…¨ãƒ†ã‚¹ãƒˆãŒæˆåŠŸã—ã¾ã—ãŸ' : 'ä¸€éƒ¨ã®ãƒ†ã‚¹ãƒˆãŒå¤±æ•—ã—ã¾ã—ãŸ'
  );
}
function runCompleteSystemTest() {
  if (!config.isDevelopment()) {
    return SystemUtils.formatResponse(false, null, 'Development mode only');
  }
  try {
    console.log("ğŸš€ å®Œå…¨ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆé–‹å§‹");
    const initResult = initializeSystem();
    const testResults = runSystemTests();
    const healthCheck = SystemHealthCheck.performHealthCheck();
    console.log("ğŸ“Š è¨­å®šç¢ºèª:");
    console.log("  - ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆID:", config.getSpreadsheetId());
    console.log("  - AIãƒ¢ãƒ‡ãƒ«:", config.getModel());
    console.log("  - ã‚®ã‚¬ãƒ•ã‚¡ã‚¤ãƒ«ä¾¿æœ‰åŠ¹:", config.isGigaFileEnabled());
    console.log("  - å®Ÿè¡Œç’°å¢ƒ:", config.get('ENVIRONMENT'));
    const success = testResults.success && healthCheck.status === 'healthy';
    const message = success ? "ğŸ‰ å…¨ãƒ†ã‚¹ãƒˆæˆåŠŸï¼ã‚·ã‚¹ãƒ†ãƒ ã¯å®Œå…¨ã«å‹•ä½œå¯èƒ½ã§ã™" : "âš ï¸ ä¸€éƒ¨ãƒ†ã‚¹ãƒˆã«å•é¡ŒãŒã‚ã‚Šã¾ã™";
    console.log(message);
    return SystemUtils.formatResponse(success, {
      initResult,
      testResults,
      healthCheck
    }, message);
  } catch (error) {
    console.error("âŒ ãƒ†ã‚¹ãƒˆå®Ÿè¡Œã‚¨ãƒ©ãƒ¼:", error);
    return SystemUtils.formatResponse(false, { error: error.message });
  }
}
// CORSãƒ†ã‚¹ãƒˆç”¨ã®é–¢æ•°
function testCORS() {
  try {
    console.log('CORSè¨­å®šãƒ†ã‚¹ãƒˆé–‹å§‹...');
    
    // doOptionsãƒ†ã‚¹ãƒˆ
    const optionsResponse = doOptions();
    console.log('doOptions æˆåŠŸ');
    
    // createJsonResponseãƒ†ã‚¹ãƒˆ
    const jsonResponse = createJsonResponse({test: 'success'});
    console.log('createJsonResponse æˆåŠŸ');
    
    // doPostã®CORSãƒ˜ãƒƒãƒ€ãƒ¼è¨­å®šãƒ†ã‚¹ãƒˆ
    console.log('doPosté–¢æ•°å†…ã®CORSãƒ˜ãƒƒãƒ€ãƒ¼è¨­å®šã‚’ç¢ºèªä¸­...');
    
    return 'CORSè¨­å®šãƒ†ã‚¹ãƒˆæˆåŠŸ - doPosté–¢æ•°å†…ã§ãƒ˜ãƒƒãƒ€ãƒ¼è¨­å®š';
  } catch (error) {
    console.error('CORSè¨­å®šãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:', error);
    return 'CORSè¨­å®šãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ' + error.message;
  }
}